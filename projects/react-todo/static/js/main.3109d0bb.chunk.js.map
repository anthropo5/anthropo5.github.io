{"version":3,"sources":["containers/AddTodoItem.js","components/About.js","components/TodoItem.js","components/TodoList.js","components/DisplayArea.js","components/UI/Input.js","containers/AddItem.js","containers/App.js","serviceWorker.js","index.js"],"names":["Component","style","width","About","href","target","TodoItem","props","description","item","length","substring","concat","onClick","onDescriptionClick","title","onRemoveClick","onEditClick","onChange","onCheckboxClick","type","checked","isDone","TodoList","todos","map","todoItem","key","onItemDescriptionClick","onRemoveButtonClick","onEditButtonClick","DisplayArea","todo","Fragment","Input","inputElement","elementType","elementConfig","value","changed","errors","invalid","touched","errorMessage","index","label","AddItem","state","addForm","placeholder","validation","required","minLength","maxLength","valid","isValid","editing","isNewEditElement","toEdit","loadEditElementToForm","updatedForm","updatedFormTitle","updatedFormDescription","setState","inputChangedHandler","ev","inputKey","updatedFormElement","checkValidity","isFormValid","element","rules","trim","push","form","onAddClick","preventDefault","newTodo","createTodo","onAddButtonClick","resetForm","onUpdateClick","oldItem","newItem","onUpdateButtonClick","generateInputElements","formElementsArray","id","config","formElement","generateInputElement","event","this","action","disabled","margin","App","display","setItemToDisplay","addTodoItem","updatedTodos","removeTodo","filter","toggleItemStatus","setItemToEdit","updateItem","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"4bAG0BA,Y,ICDpBC,EAAQ,CACZC,MAAO,SAiBMC,EAdD,WACZ,OACE,6BACE,qCACA,uBAAGF,MAAOA,GAAV,mJAIA,oGAAyE,uBAAGG,KAAK,IAAIC,OAAO,UAAnB,WACzE,+BCoBSC,EAhCE,SAAAC,GACf,IAAIC,EAAcD,EAAME,KAAKD,YAK7B,OAJIA,EAAYE,OAAS,KACvBF,EAAcA,EAAYG,UAAU,EAAG,IAAIC,OAAO,uBAIlD,6BACE,yBAAKC,QAAS,kBAAMN,EAAMO,mBAAmBP,EAAME,QACjD,2BAAIF,EAAME,KAAKM,OACf,2BAAIP,IAEN,4BAAQK,QAAS,kBAAMN,EAAMS,cAAcT,EAAME,KAAKM,SAAtD,UAGA,4BAAQF,QAAS,WAAON,EAAMU,YAAYV,EAAME,QAAhD,QACA,+BACE,2BAAOS,SAAU,kBAAMX,EAAMY,gBAAgBZ,EAAME,OAAOW,KAAK,WAAWC,QAASd,EAAME,KAAKa,SADhG,aCQSC,EAxBE,SAAAhB,GACf,IAAIiB,EAAQ,4CAiBZ,OAfIjB,EAAMiB,QACRA,EAAQjB,EAAMiB,MAAMC,KAAI,SAAAC,GACtB,OACE,kBAAC,EAAD,CACEC,IAAKD,EAASX,MACdN,KAAMiB,EACNZ,mBAAoBP,EAAMqB,uBAC1BZ,cAAeT,EAAMsB,oBACrBV,gBAAiBZ,EAAMY,gBACvBF,YAAaV,EAAMuB,wBAMnB,6BACR,yCACCN,ICHYO,EAlBK,SAACxB,GACjB,IAAIyB,EAAO,mEAUX,OARGzB,EAAMyB,OACLA,EAAO,kBAAC,IAAMC,SAAP,KACH,4BAAK1B,EAAMyB,KAAKjB,OAChB,2BAAIR,EAAMyB,KAAKxB,eAMnB,6BACKwB,IC6BEE,EA1CD,SAAA3B,GACZ,IAAI4B,EAAe,KACnB,OAAQ5B,EAAM6B,aACZ,IAAK,QACHD,EACE,2CACM5B,EAAM8B,cADZ,CAEEC,MAAO/B,EAAM+B,MACbpB,SAAUX,EAAMgC,WAGpB,MACF,IAAK,WACHJ,EACE,8CACM5B,EAAM8B,cADZ,CAEEC,MAAO/B,EAAM+B,MACbpB,SAAUX,EAAMgC,WAGpB,MACF,QACEJ,EAAe,2CAAW5B,EAAM8B,cAAjB,CAAgCC,MAAO/B,EAAM+B,SAGhE,IAAIE,EAAS,KAMb,OALIjC,EAAMkC,SAAWlC,EAAMmC,UACzBF,EAASjC,EAAMiC,OAAOf,KAAI,SAACkB,EAAcC,GACvC,OAAO,uBAAGjB,IAAKiB,GAAQD,OAIzB,6BACGH,EACD,+BACGjC,EAAMsC,MACNV,K,6jBC8MMW,E,2MAhPbC,MAAQ,CACNC,QAAS,CACPjC,MAAO,CACLqB,YAAa,QACbC,cAAe,CACbjB,KAAM,OACN6B,YAAa,SAEfC,WAAY,CACVC,UAAU,EACVC,UAAW,EACXC,UAAW,IAEbC,OAAO,EACPZ,SAAS,EACTF,OAAQ,GACRF,MAAO,IAET9B,YAAa,CACX4B,YAAa,WACbC,cAAe,CACbjB,KAAM,WACN6B,YAAa,eAEfC,WAAY,CACVC,UAAU,GAEZG,OAAO,EACPZ,SAAS,EACTF,OAAQ,GACRF,MAAO,KAGXiB,SAAS,EACTC,QAAS,M,EAWXC,iBAAmB,WACjB,OAAO,EAAKV,MAAMS,UAAY,EAAKjD,MAAMmD,Q,EAG3CC,sBAAwB,WACtB,IAGMC,EAAW,KAAQ,EAAKb,MAAMC,SAC9Ba,EAAgB,KAAQD,EAAW,OACnCE,EAAsB,KAAQF,EAAW,aAE/CC,EAAiBvB,MAAQ,EAAK/B,MAAMmD,OAAO3C,MAC3C+C,EAAuBxB,MAAQ,EAAK/B,MAAMmD,OAAOlD,YAEjDoD,EAAW,MAAUC,EACrBD,EAAW,YAAgBE,EAE3B,EAAKC,SAAS,CACZf,QAASY,EACTJ,QAAS,EAAKjD,MAAMmD,U,EAIxBM,oBAAsB,SAACC,EAAIC,GACzB,IAAMN,EAAW,KAAQ,EAAKb,MAAMC,SAC9BmB,EAAkB,KAAQP,EAAYM,IAE5CC,EAAmB7B,MAAQ2B,EAAG5D,OAAOiC,MACrC6B,EAAmBzB,SAAU,EAE7BkB,EAAYM,GAAYC,EAExB,EAAKC,cAAcD,GACnB,IAAIZ,EAAU,EAAKc,YAAYT,GAE/B,EAAKG,SAAS,CACZf,QAASY,EACTL,QAASA,K,EAIba,cAAgB,SAAAE,GACd,IAAMC,EAAQD,EAAQpB,WAChBZ,EAAQgC,EAAQhC,MAKtB,OAJAgC,EAAQhB,OAAQ,EAChBgB,EAAQ9B,OAAS,GAGb+B,EAAMpB,UACa,KAAjBb,EAAMkC,QACRF,EAAQ9B,OAAOiC,KAAK,qBACZH,EAAQhB,OAAQ,IAIxBiB,EAAMnB,WACJd,EAAM5B,OAAS6D,EAAMnB,YACvBkB,EAAQ9B,OAAOiC,KAAK,iBAAmBF,EAAMnB,WAC7CkB,EAAQhB,OAAQ,GAIhBiB,EAAMlB,WACJf,EAAM5B,OAAS6D,EAAMlB,YACvBiB,EAAQ9B,OAAOiC,KAAK,iBAAmBF,EAAMlB,WAC7CiB,EAAQhB,OAAQ,GAIbgB,EAAQhB,Q,EAGjBe,YAAc,SAAAK,GACZ,IAAInB,GAAU,EACd,IAAK,IAAI5B,KAAO+C,EACdnB,EAAUmB,EAAK/C,GAAK2B,OAASC,EAE/B,OAAOA,G,EAGToB,WAAa,SAAAV,GACXA,EAAGW,iBACH,IAAMC,EAAU,EAAKC,aACrB,EAAKvE,MAAMwE,iBAAiBF,GAC5B,EAAKG,a,EAGPC,cAAgB,SAAAhB,GAGd,GAFAA,EAAGW,iBAEC,EAAKrE,MAAMmD,OAAQ,CACrB,IAAMwB,EAAU,EAAK3E,MAAMmD,OACrByB,EAAU,EAAKL,aAErB,EAAKvE,MAAM6E,oBAAoBF,EAASC,GACxC,EAAKH,c,EAYTA,UAAY,WACV,EAAKjB,SAAS,CACZf,QAAS,CACPjC,MAAO,CACLqB,YAAa,QACbC,cAAe,CACbjB,KAAM,OACN6B,YAAa,SAEfC,WAAY,CACVC,UAAU,EACVC,UAAW,EACXC,UAAW,IAEbC,OAAO,EACPZ,SAAS,EACTF,OAAQ,GACRF,MAAO,IAET9B,YAAa,CACX4B,YAAa,WACbC,cAAe,CACbjB,KAAM,WACN6B,YAAa,eAEfC,WAAY,CACVC,UAAU,GAEZG,OAAO,EACPZ,SAAS,EACTF,OAAQ,GACRF,MAAO,KAGXiB,SAAS,EACTC,QAAS,Q,EAoBb6B,sBAAwB,WACtB,IAAMC,EAAoB,GAC1B,IAAK,IAAI3D,KAAO,EAAKoB,MAAMC,QACzBsC,EAAkBb,KAAK,CACrBc,GAAI5D,EACJ6D,OAAQ,EAAKzC,MAAMC,QAAQrB,KAI/B,OAAO2D,EAAkB7D,KAAI,SAAAgE,GAC3B,OACE,EAAKC,qBAAqBD,O,EAKhCC,qBAAuB,SAAAD,GACrB,OAAO,kBAAC,EAAD,CACL9D,IAAK8D,EAAYF,GACjBnD,YAAaqD,EAAYD,OAAOpD,YAChCC,cAAeoD,EAAYD,OAAOnD,cAClCC,MAAOmD,EAAYD,OAAOlD,MAC1BC,QAAS,SAAAoD,GACP,EAAK3B,oBAAoB2B,EAAOF,EAAYF,KAE9C9C,SAAUgD,EAAYD,OAAOlC,MAC7BZ,QAAS+C,EAAYD,OAAO9C,QAC5BF,OAAQiD,EAAYD,OAAOhD,U,oFArMzBoD,KAAKrF,MAAMmD,QACTkC,KAAKnC,oBACPmC,KAAKjC,0B,mCA0GT,MAAO,CACL5C,MAAO6E,KAAK7C,MAAMC,QAAQjC,MAAMuB,MAChC9B,YAAaoF,KAAK7C,MAAMC,QAAQxC,YAAY8B,MAC5ChB,QAAQ,K,+BA4CV,OACE,6BACE,0BAAMuE,OAAO,IACVD,KAAKP,wBACN,4BAAQxE,QAAS+E,KAAKjB,WAAYmB,UAAWF,KAAK7C,MAAMQ,SAAxD,OAGA,4BAAQ1C,QAAS+E,KAAKX,cAAea,UAAWF,KAAK7C,MAAMQ,SAA3D,gB,GAzMYvD,aCShBC,EAAQ,CACZC,MAAO,QACP6F,OAAQ,UA2IKC,E,2MAvIbjD,MAAQ,CACNkD,QAAS,KACTvC,OAAQ,KACRlC,MAAO,CACL,CACET,MAAO,QACPO,QAAQ,EACRd,YAAa,oBAEf,CACEO,MAAO,OACPO,QAAQ,EACRd,YACE,mE,EAKRoB,uBAAyB,SAAAI,GACvB,EAAKkE,iBAAiBlE,I,EAGxBkE,iBAAmB,SAAAlE,GACjB,EAAK+B,SAAS,CACZkC,QAASjE,K,EAIb+C,iBAAmB,SAAA/C,GACjB,EAAK+B,SAAS,CACZvC,MAAO,EAAK2E,YAAYnE,M,EAI5BmE,YAAc,SAAAnE,GACZ,IAAIoE,EAAY,YAAO,EAAKrD,MAAMvB,OAElC,OADA4E,EAAa3B,KAAKzC,GACXoE,G,EAGTvE,oBAAsB,SAAAd,GAChB,EAAKgC,MAAMkD,SAAW,EAAKlD,MAAMkD,QAAQlF,QAAUA,GACrD,EAAKmF,iBAAiB,MAExB,EAAKnC,SAAS,CACZvC,MAAO,EAAK6E,WAAWtF,M,EAI3BsF,WAAa,SAAAtF,GAEX,OADgB,YAAO,EAAKgC,MAAMvB,OACd8E,QAAO,SAAAtE,GACzB,OAAOA,EAAKjB,QAAUA,M,EAI1BI,gBAAkB,SAAAa,GAChB,EAAK+B,SAAS,CACZvC,MAAO,EAAK+E,iBAAiBvE,M,EAIjCuE,iBAAmB,SAAAvE,GACjB,IAAIoE,EAAY,YAAO,EAAKrD,MAAMvB,OAQlC,OAPA4E,EACGE,QAAO,SAAA7F,GACN,OAAOA,EAAKM,QAAUiB,EAAKjB,SAE5BU,KAAI,SAAAhB,GACH,OAAQA,EAAKa,QAAUU,EAAKV,UAEzB8E,G,EAGTtE,kBAAoB,SAAAE,GAClB,EAAKwE,cAAcxE,I,EAGrBwE,cAAgB,SAAAxE,GACd,EAAK+B,SAAS,CACZL,OAAQ1B,K,EAIZoD,oBAAsB,SAACF,EAASC,GAC9B,EAAKpB,SAAS,CACZvC,MAAO,EAAKiF,WAAWvB,EAASC,GAChCzB,OAAQ,Q,EAIZ+C,WAAa,SAACvB,EAASC,GACrB,IAAIiB,EAAY,YAAO,EAAKrD,MAAMvB,OASlC,OARA4E,EACGE,QAAO,SAAA7F,GACN,OAAOA,EAAKM,QAAUmE,EAAQnE,SAE/BU,KAAI,SAAAhB,GACHA,EAAKM,MAAQoE,EAAQpE,MACrBN,EAAKD,YAAc2E,EAAQ3E,eAExB4F,G,wEAIP,OACE,yBAAKnG,MAAOA,GACV,kBAAC,EAAD,MACA,kBAAC,EAAD,CACEuB,MAAOoE,KAAK7C,MAAMvB,MAClBI,uBAAwBgE,KAAKhE,uBAC7BC,oBAAqB+D,KAAK/D,oBAC1BC,kBAAmB8D,KAAK9D,kBACxBX,gBAAiByE,KAAKzE,kBAExB,6BACA,kBAAC,EAAD,CAAaa,KAAM4D,KAAK7C,MAAMkD,UAC9B,6BACA,sCACA,kBAAC,EAAD,CACElB,iBAAkBa,KAAKb,iBACvBK,oBAAqBQ,KAAKR,oBAC1B1B,OAAQkC,KAAK7C,MAAMW,c,GA3HX1D,aCLE0G,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCbNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD4H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,iB","file":"static/js/main.3109d0bb.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { pipelineTopicExpression } from \"@babel/types\";\n\nclass AddTodoItem extends Component {\n  state = {\n    form: {\n      title: \"\",\n      description: \"\"\n    },\n    editing: null,\n    isValid: false,\n    errors: null,\n    touched: false\n  };\n\n  componentDidUpdate() {\n    if (this.props.toEdit) {\n      if (this.state.editing !== this.props.toEdit) {\n        this.setState({\n          form: {\n            title: this.props.toEdit.title,\n            description: this.props.toEdit.description\n          },\n          editing: this.props.toEdit\n        });\n      }\n    }\n  }\n\n  onInputChange = ev => {\n    let updatedForm = { ...this.state.form };\n    const name = ev.target.name;\n    if(name === 'title') {\n      this.setState({\n        touched: true\n      })\n    }\n    updatedForm[name] = ev.target.value;\n    \n\n    this.setState({\n      form: updatedForm\n    });\n  };\n\n  onAddClick = ev => {\n    ev.preventDefault();\n    \n    if(!this.isValid()) {\n      return;\n    }\n\n    const newTodo = this.createTodo();\n    this.props.onAddButtonClick(newTodo);\n    this.resetForm();\n  };\n\n  isValid = () => {\n    let isValid = true;\n\n    console.log(this.state.isValid);\n    \n\n    if(this.state.form.title.length < 3) {\n      isValid = false && isValid; \n    }\n\n    this.setState({\n      isValid: isValid\n    })\n\n    return isValid;\n  }\n\n  createTodo() {\n    return {\n      title: this.state.form.title,\n      description: this.state.form.description,\n      isDone: false\n    };\n  }\n\n  resetForm = () => {\n    this.setState({\n      form: {\n        title: \"\",\n        description: \"\"\n      },\n      editing: null,\n      touched: false\n    });\n  };\n\n  onUpdateClick = ev => {\n    ev.preventDefault();\n\n    if (this.props.toEdit) {\n      if(!this.isValid()) {\n        return;\n      }\n \n      const newItem = this.createTodo();\n      const oldItem = this.props.toEdit;\n      this.props.onUpdateButtonClick(oldItem, newItem);\n      this.resetForm();\n    }\n  };\n\n  render() {\n\n    let errors = null;\n    if(!this.state.isValid && this.state.touched) {\n      errors = <p>Legnth should be > 3</p>\n    }\n\n\n    return (\n      <div>\n        <form action=\"\">\n          <label>\n            title\n            <input\n              type=\"text\"\n              name=\"title\"\n              onChange={this.onInputChange}\n              value={this.state.form.title}\n            />\n          </label>\n          {errors}\n          <br />\n          <label>description\n            <textarea\n              name=\"description\"\n              onChange={this.onInputChange}\n              cols=\"30\"\n              rows=\"10\"\n              value={this.state.form.description}\n            />\n          </label>\n          <br />\n          <button onClick={this.onAddClick}>Add</button>\n          <button onClick={this.onUpdateClick}>Update</button>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default AddTodoItem;\n","import React from \"react\";\n\nconst style = {\n  width: 400 + \"px\"\n};\n\nconst About = () => {\n  return (\n    <div>\n      <h1>notes</h1>\n      <p style={style}>\n        Assume that todo \"title\" is unique value. There is no validation if it\n        really is. In real world application it would be some unique ID from DB.\n      </p>\n      <p>I focused only at logic. It is clean React solution. Please check the <a href=\"#\" target=\"_blank\">source</a></p>\n      <hr />\n    </div>\n  );\n};\n\nexport default About;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nconst TodoItem = props => {\n  let description = props.item.description;\n  if (description.length > 20) {\n    description = description.substring(0, 20).concat(\"...[click to show]\");\n  }\n\n  return (\n    <div>\n      <div onClick={() => props.onDescriptionClick(props.item)}>\n        <p>{props.item.title}</p>\n        <p>{description}</p>\n      </div>\n      <button onClick={() => props.onRemoveClick(props.item.title)}>\n        remove\n      </button>\n      <button onClick={() => {props.onEditClick(props.item)}}>edit</button>\n      <label >\n        <input onChange={() => props.onCheckboxClick(props.item)} type=\"checkbox\" checked={props.item.isDone} />\n        is done\n      </label>\n    </div>\n  );\n};\n\nTodoItem.propTypes = {\n\n  item: PropTypes.shape({\n    title: PropTypes.string\n  }),\n  onDescriptionClick: PropTypes.func.isRequired\n};\n\nexport default TodoItem;\n","import React from \"react\";\nimport TodoItem from \"./TodoItem\";\n\nconst TodoList = props => {\n  let todos = <p>List is empty</p>;\n\n  if (props.todos) {\n    todos = props.todos.map(todoItem => {\n      return (\n        <TodoItem\n          key={todoItem.title}\n          item={todoItem}\n          onDescriptionClick={props.onItemDescriptionClick}\n          onRemoveClick={props.onRemoveButtonClick}\n          onCheckboxClick={props.onCheckboxClick}\n          onEditClick={props.onEditButtonClick}\n        />\n      );\n    });\n  }\n\n  return (<div>\n  <h2>TODO List</h2>\n  {todos}\n  </div>);\n};\n\nexport default TodoList;\n","import React from 'react'\n\nconst DisplayArea = (props) => {\n    let todo = <p>select todo to show full description</p>\n    \n    if(props.todo) {\n        todo = <React.Fragment>\n            <h2>{props.todo.title}</h2>\n            <p>{props.todo.description}</p>\n        </React.Fragment>\n\n    }\n\n    return (\n        <div>\n            {todo}\n        </div>\n    )\n}\n\nexport default DisplayArea\n","import React from \"react\";\n\nconst Input = props => {\n  let inputElement = null;\n  switch (props.elementType) {\n    case \"input\":\n      inputElement = (\n        <input\n          {...props.elementConfig}\n          value={props.value}\n          onChange={props.changed}\n        />\n      );\n      break;\n    case \"textarea\":\n      inputElement = (\n        <textarea\n          {...props.elementConfig}\n          value={props.value}\n          onChange={props.changed}\n        />\n      );\n      break;\n    default:\n      inputElement = <input {...props.elementConfig} value={props.value} />;\n  }\n\n  let errors = null;\n  if (props.invalid && props.touched) {\n    errors = props.errors.map((errorMessage, index) => {\n      return <p key={index}>{errorMessage}</p>;\n    });\n  }\n  return (\n    <div>\n      {errors}\n      <label>\n        {props.label}\n        {inputElement}\n      </label>\n    </div>\n  );\n};\n\nexport default Input;\n","import React, { Component } from \"react\";\nimport Input from \"../components/UI/Input\";\n\nclass AddItem extends Component {\n  state = {\n    addForm: {\n      title: {\n        elementType: \"input\",\n        elementConfig: {\n          type: \"text\",\n          placeholder: \"Title\"\n        },\n        validation: {\n          required: true,\n          minLength: 3,\n          maxLength: 10\n        },\n        valid: false,\n        touched: false,\n        errors: [],\n        value: \"\"\n      },\n      description: {\n        elementType: \"textarea\",\n        elementConfig: {\n          type: \"textarea\",\n          placeholder: \"Description\"\n        },\n        validation: {\n          required: false\n        },\n        valid: true,\n        touched: false,\n        errors: [],\n        value: \"\"\n      }\n    },\n    isValid: false,\n    editing: null\n  };\n\n  componentDidUpdate() {\n    if (this.props.toEdit) {\n      if (this.isNewEditElement()) {\n        this.loadEditElementToForm();\n      }\n    }\n  }\n\n  isNewEditElement = () => {\n    return this.state.editing !== this.props.toEdit;\n  };\n\n  loadEditElementToForm = () => {\n    const TITLE = \"title\";\n    const DESCRIPTION = \"description\";\n\n    const updatedForm = { ...this.state.addForm };\n    const updatedFormTitle = { ...updatedForm[TITLE] };\n    const updatedFormDescription = { ...updatedForm[DESCRIPTION] };\n\n    updatedFormTitle.value = this.props.toEdit.title;\n    updatedFormDescription.value = this.props.toEdit.description;\n\n    updatedForm[TITLE] = updatedFormTitle;\n    updatedForm[DESCRIPTION] = updatedFormDescription;\n\n    this.setState({\n      addForm: updatedForm,\n      editing: this.props.toEdit\n    });\n  };\n\n  inputChangedHandler = (ev, inputKey) => {\n    const updatedForm = { ...this.state.addForm };\n    const updatedFormElement = { ...updatedForm[inputKey] };\n\n    updatedFormElement.value = ev.target.value;\n    updatedFormElement.touched = true;\n\n    updatedForm[inputKey] = updatedFormElement;\n\n    this.checkValidity(updatedFormElement);\n    let isValid = this.isFormValid(updatedForm);\n\n    this.setState({\n      addForm: updatedForm,\n      isValid: isValid\n    });\n  };\n\n  checkValidity = element => {\n    const rules = element.validation;\n    const value = element.value;\n    element.valid = true;\n    element.errors = [];\n\n    // some OOP to refactor for more generic solution would be nice.\n    if (rules.required) {\n      if (value.trim() === \"\") {\n        element.errors.push(\"Field is required\");\n        return (element.valid = false);\n      }\n    }\n\n    if (rules.minLength) {\n      if (value.length < rules.minLength) {\n        element.errors.push(\"Min length is \" + rules.minLength);\n        element.valid = false;\n      }\n    }\n\n    if (rules.maxLength) {\n      if (value.length > rules.maxLength) {\n        element.errors.push(\"Max length is \" + rules.maxLength);\n        element.valid = false;\n      }\n    }\n\n    return element.valid;\n  };\n\n  isFormValid = form => {\n    let isValid = true;\n    for (let key in form) {\n      isValid = form[key].valid && isValid;\n    }\n    return isValid;\n  };\n\n  onAddClick = ev => {\n    ev.preventDefault();\n    const newTodo = this.createTodo();\n    this.props.onAddButtonClick(newTodo);\n    this.resetForm();\n  };\n\n  onUpdateClick = ev => {\n    ev.preventDefault();\n\n    if (this.props.toEdit) {\n      const oldItem = this.props.toEdit;\n      const newItem = this.createTodo();\n      // maybe it would be better if creating new item would be resposibility of this container and pass just newItem.\n      this.props.onUpdateButtonClick(oldItem, newItem);\n      this.resetForm();\n    }\n  };\n\n  createTodo() {\n    return {\n      title: this.state.addForm.title.value,\n      description: this.state.addForm.description.value,\n      isDone: false\n    };\n  }\n\n  resetForm = () => {\n    this.setState({\n      addForm: {\n        title: {\n          elementType: \"input\",\n          elementConfig: {\n            type: \"text\",\n            placeholder: \"Title\"\n          },\n          validation: {\n            required: true,\n            minLength: 3,\n            maxLength: 10\n          },\n          valid: false,\n          touched: false,\n          errors: [],\n          value: \"\"\n        },\n        description: {\n          elementType: \"textarea\",\n          elementConfig: {\n            type: \"textarea\",\n            placeholder: \"Description\"\n          },\n          validation: {\n            required: false\n          },\n          valid: true,\n          touched: false,\n          errors: [],\n          value: \"\"\n        }\n      },\n      isValid: false,\n      editing: null\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <form action=\"\">\n          {this.generateInputElements()}\n          <button onClick={this.onAddClick} disabled={!this.state.isValid}>\n            Add\n          </button>\n          <button onClick={this.onUpdateClick} disabled={!this.state.isValid}>\n            Update\n          </button>\n        </form>\n      </div>\n    );\n  }\n\n  generateInputElements = () => {\n    const formElementsArray = [];\n    for (let key in this.state.addForm) {\n      formElementsArray.push({\n        id: key,\n        config: this.state.addForm[key]\n      });\n    }\n\n    return formElementsArray.map(formElement => {\n      return (\n        this.generateInputElement(formElement)\n      );\n    });\n  };\n\n  generateInputElement = formElement => {\n    return <Input\n      key={formElement.id}\n      elementType={formElement.config.elementType}\n      elementConfig={formElement.config.elementConfig}\n      value={formElement.config.value}\n      changed={event => {\n        this.inputChangedHandler(event, formElement.id);\n      }}\n      invalid={!formElement.config.valid}\n      touched={formElement.config.touched}\n      errors={formElement.config.errors}\n    />;\n  };\n}\n\nexport default AddItem;\n","import React, { Component } from \"react\";\nimport AddTodoItem from \"./AddTodoItem\";\nimport About from \"../components/About\";\nimport TodoList from \"../components/TodoList\";\nimport DisplayArea from \"../components/DisplayArea\";\nimport AddItem from \"./AddItem\";\n\n/*\n notes: \n    Keys and 'removeTodo' function are based on todo \"title\". Assume it is unique. \n*/\n\nconst style = {\n  width: 400 + \"px\",\n  margin: \"0 auto\"\n};\n\nclass App extends Component {\n  state = {\n    display: null,\n    toEdit: null,\n    todos: [\n      {\n        title: \"redux\",\n        isDone: false,\n        description: \"rewrite this app\"\n      },\n      {\n        title: \"java\",\n        isDone: false,\n        description:\n          \"make super REST API app with Spring and React Redux front end\"\n      }\n    ]\n  };\n\n  onItemDescriptionClick = todo => {\n    this.setItemToDisplay(todo);\n  };\n\n  setItemToDisplay = todo => {\n    this.setState({\n      display: todo\n    });\n  };\n\n  onAddButtonClick = todo => {\n    this.setState({\n      todos: this.addTodoItem(todo)\n    });\n  };\n\n  addTodoItem = todo => {\n    let updatedTodos = [...this.state.todos];\n    updatedTodos.push(todo);\n    return updatedTodos;\n  };\n\n  onRemoveButtonClick = title => {\n    if (this.state.display && this.state.display.title === title) {\n      this.setItemToDisplay(null);\n    }\n    this.setState({\n      todos: this.removeTodo(title)\n    });\n  };\n\n  removeTodo = title => {\n    let updatedTodos = [...this.state.todos];\n    return updatedTodos.filter(todo => {\n      return todo.title !== title;\n    });\n  };\n\n  onCheckboxClick = todo => {\n    this.setState({\n      todos: this.toggleItemStatus(todo)\n    });\n  };\n\n  toggleItemStatus = todo => {\n    let updatedTodos = [...this.state.todos];\n    updatedTodos\n      .filter(item => {\n        return item.title === todo.title;\n      })\n      .map(item => {\n        return (item.isDone = !todo.isDone);\n      });\n    return updatedTodos;\n  };\n\n  onEditButtonClick = todo => {\n    this.setItemToEdit(todo);\n  };\n\n  setItemToEdit = todo => {\n    this.setState({\n      toEdit: todo\n    });\n  };\n\n  onUpdateButtonClick = (oldItem, newItem) => {\n    this.setState({\n      todos: this.updateItem(oldItem, newItem),\n      toEdit: null\n    });\n  };\n\n  updateItem = (oldItem, newItem) => {\n    let updatedTodos = [...this.state.todos];\n    updatedTodos\n      .filter(item => {\n        return item.title === oldItem.title;\n      })\n      .map(item => {\n        item.title = newItem.title;\n        item.description = newItem.description;\n      });\n    return updatedTodos;\n  };\n\n  render() {\n    return (\n      <div style={style}>\n        <About />\n        <TodoList\n          todos={this.state.todos}\n          onItemDescriptionClick={this.onItemDescriptionClick}\n          onRemoveButtonClick={this.onRemoveButtonClick}\n          onEditButtonClick={this.onEditButtonClick}\n          onCheckboxClick={this.onCheckboxClick}\n        />\n        <hr />\n        <DisplayArea todo={this.state.display} />\n        <hr />\n        <p>new add</p>\n        <AddItem\n          onAddButtonClick={this.onAddButtonClick}\n          onUpdateButtonClick={this.onUpdateButtonClick}\n          toEdit={this.state.toEdit}\n        />\n      </div>\n    );\n  }\n}\n\n// <AddTodoItem\n// onAddButtonClick={this.onAddButtonClick}\n// onUpdateButtonClick={this.onUpdateButtonClick}\n// toEdit={this.state.toEdit}\n// />\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './containers/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}